// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: url_clicks.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const countClicksByShortURLID = `-- name: CountClicksByShortURLID :one
SELECT COUNT(*)
FROM url_clicks
WHERE short_url_id = ?
`

func (q *Queries) CountClicksByShortURLID(ctx context.Context, shortUrlID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countClicksByShortURLID, shortUrlID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createURLClick = `-- name: CreateURLClick :one
INSERT INTO url_clicks (short_url_id, country_code, os_name, browser_name, raw_user_agent, ip_address)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id
`

type CreateURLClickParams struct {
	ShortURLID   int64          `json:"short_url_id"`
	CountryCode  sql.NullString `json:"country_code"`
	OSName       sql.NullString `json:"os_name"`
	BrowserName  sql.NullString `json:"browser_name"`
	RawUserAgent sql.NullString `json:"raw_user_agent"`
	IPAddress    sql.NullString `json:"ip_address"`
}

func (q *Queries) CreateURLClick(ctx context.Context, arg CreateURLClickParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createURLClick,
		arg.ShortURLID,
		arg.CountryCode,
		arg.OSName,
		arg.BrowserName,
		arg.RawUserAgent,
		arg.IPAddress,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getClickStatsByBrowser = `-- name: GetClickStatsByBrowser :many
SELECT
    browser_name,
    COUNT(*) as count
FROM url_clicks
WHERE short_url_id = ? AND clicked_at >= ?2 AND clicked_at <= ?3
GROUP BY browser_name
ORDER BY count DESC
`

type GetClickStatsByBrowserParams struct {
	ShortURLID int64     `json:"short_url_id"`
	From       time.Time `json:"from"`
	To         time.Time `json:"to"`
}

type GetClickStatsByBrowserRow struct {
	BrowserName sql.NullString `json:"browser_name"`
	Count       int64          `json:"count"`
}

func (q *Queries) GetClickStatsByBrowser(ctx context.Context, arg GetClickStatsByBrowserParams) ([]GetClickStatsByBrowserRow, error) {
	rows, err := q.db.QueryContext(ctx, getClickStatsByBrowser, arg.ShortURLID, arg.From, arg.To)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClickStatsByBrowserRow{}
	for rows.Next() {
		var i GetClickStatsByBrowserRow
		if err := rows.Scan(&i.BrowserName, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClickStatsByCountry = `-- name: GetClickStatsByCountry :many
SELECT
    country_code,
    COUNT(*) as count
FROM url_clicks
WHERE short_url_id = ? AND clicked_at >= ?2 AND clicked_at <= ?3
GROUP BY country_code
ORDER BY count DESC
`

type GetClickStatsByCountryParams struct {
	ShortURLID int64     `json:"short_url_id"`
	From       time.Time `json:"from"`
	To         time.Time `json:"to"`
}

type GetClickStatsByCountryRow struct {
	CountryCode sql.NullString `json:"country_code"`
	Count       int64          `json:"count"`
}

func (q *Queries) GetClickStatsByCountry(ctx context.Context, arg GetClickStatsByCountryParams) ([]GetClickStatsByCountryRow, error) {
	rows, err := q.db.QueryContext(ctx, getClickStatsByCountry, arg.ShortURLID, arg.From, arg.To)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClickStatsByCountryRow{}
	for rows.Next() {
		var i GetClickStatsByCountryRow
		if err := rows.Scan(&i.CountryCode, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClickStatsByOS = `-- name: GetClickStatsByOS :many
SELECT
    os_name,
    COUNT(*) as count
FROM url_clicks
WHERE short_url_id = ? AND clicked_at >= ?2 AND clicked_at <= ?3
GROUP BY os_name
ORDER BY count DESC
`

type GetClickStatsByOSParams struct {
	ShortURLID int64     `json:"short_url_id"`
	From       time.Time `json:"from"`
	To         time.Time `json:"to"`
}

type GetClickStatsByOSRow struct {
	OSName sql.NullString `json:"os_name"`
	Count  int64          `json:"count"`
}

func (q *Queries) GetClickStatsByOS(ctx context.Context, arg GetClickStatsByOSParams) ([]GetClickStatsByOSRow, error) {
	rows, err := q.db.QueryContext(ctx, getClickStatsByOS, arg.ShortURLID, arg.From, arg.To)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClickStatsByOSRow{}
	for rows.Next() {
		var i GetClickStatsByOSRow
		if err := rows.Scan(&i.OSName, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClickStatsByTime = `-- name: GetClickStatsByTime :many
SELECT
    strftime('%Y-%m-%dT%H:00:00Z', clicked_at) as time_bucket,
    COUNT(*) as count
FROM url_clicks
WHERE short_url_id = ? AND clicked_at >= ?2 AND clicked_at <= ?3
GROUP BY time_bucket
ORDER BY time_bucket
`

type GetClickStatsByTimeParams struct {
	ShortURLID int64     `json:"short_url_id"`
	From       time.Time `json:"from"`
	To         time.Time `json:"to"`
}

type GetClickStatsByTimeRow struct {
	TimeBucket interface{} `json:"time_bucket"`
	Count      int64       `json:"count"`
}

func (q *Queries) GetClickStatsByTime(ctx context.Context, arg GetClickStatsByTimeParams) ([]GetClickStatsByTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, getClickStatsByTime, arg.ShortURLID, arg.From, arg.To)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClickStatsByTimeRow{}
	for rows.Next() {
		var i GetClickStatsByTimeRow
		if err := rows.Scan(&i.TimeBucket, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnprocessedClicks = `-- name: GetUnprocessedClicks :many

SELECT id, ip_address
FROM url_clicks
WHERE is_processed = FALSE AND ip_address IS NOT NULL AND ip_address != ''
LIMIT ?
`

type GetUnprocessedClicksRow struct {
	ID        int64          `json:"id"`
	IPAddress sql.NullString `json:"ip_address"`
}

// TODO: Add query to get other stats
func (q *Queries) GetUnprocessedClicks(ctx context.Context, limit int64) ([]GetUnprocessedClicksRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnprocessedClicks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnprocessedClicksRow{}
	for rows.Next() {
		var i GetUnprocessedClicksRow
		if err := rows.Scan(&i.ID, &i.IPAddress); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClickGeoInfo = `-- name: UpdateClickGeoInfo :exec
UPDATE url_clicks
SET
    is_success = ?,
    country = ?,
    region_name = ?,
    city = ?,
    lat = ?,
    lon = ?,
    isp = ?,
    as_info = ?,
    is_processed = TRUE
WHERE ip_address = ?
`

type UpdateClickGeoInfoParams struct {
	IsSuccess  bool            `json:"is_success"`
	Country    sql.NullString  `json:"country"`
	RegionName sql.NullString  `json:"region_name"`
	City       sql.NullString  `json:"city"`
	Lat        sql.NullFloat64 `json:"lat"`
	Lon        sql.NullFloat64 `json:"lon"`
	Isp        sql.NullString  `json:"isp"`
	AsInfo     sql.NullString  `json:"as_info"`
	IPAddress  sql.NullString  `json:"ip_address"`
}

func (q *Queries) UpdateClickGeoInfo(ctx context.Context, arg UpdateClickGeoInfoParams) error {
	_, err := q.db.ExecContext(ctx, updateClickGeoInfo,
		arg.IsSuccess,
		arg.Country,
		arg.RegionName,
		arg.City,
		arg.Lat,
		arg.Lon,
		arg.Isp,
		arg.AsInfo,
		arg.IPAddress,
	)
	return err
}
